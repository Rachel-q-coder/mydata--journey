# 178.Oder-Score

## 题目描述：

编写一个解决方案来查询分数的排名。排名按以下规则计算:

-分数应按从高到低排列。

-如果两个分数相等，那么两个分数的排名应该相同。

-在排名相同的分数后，排名数应该是下一个连续的整数。换

-句话说，排名之间不应该有空缺的数字。

-按 score 降序返回结果表。

### 输入: 
Scores 表:
```
+----+-------+
| id | score |
+----+-------+
| 1  | 3.50  |
| 2  | 3.65  |
| 3  | 4.00  |
| 4  | 3.85  |
| 5  | 4.00  |
| 6  | 3.65  |
+----+-------+
```
### 输出: 
```
+-------+------+
| score | rank |
+-------+------+
| 4.00  | 1    |
| 4.00  | 1    |
| 3.85  | 2    |
| 3.65  | 3    |
| 3.65  | 3    |
| 3.50  | 4    |
+-------+------+
```

## 我的思路：

1.**需求分析：** -从高到低：desc；

-分数相等，排名相等，且不跳数字;

2.**解题思路：** 直接采用窗口函数：dence_rank

## SQL代码

```
SELECT 
    score ,
    DENSE_RANK() OVER(ORDER BY CAST(score AS DOUBLE) DESC) as `rank`
FROM scores;
```

## 其他解法：

### SQL代码

```
SELECT
  S1.score,
  (
    SELECT
      COUNT(DISTINCT S2.score)
    FROM
      Scores S2
    WHERE
      S2.score >= S1.score
  ) AS 'rank'
FROM
  Scores S1
ORDER BY
  S1.score DESC;

```

## 代码分析：

-采用相关子查询：确认外部查询的每一个数据，如此时分数是90，子查询：遍历表上score数据，找出分数>=外部的90

-执行过程模拟
假设数据：Scores = [100, 90, 80]

-第1步：处理 S1.score = 100
sql
外部查询：取出分数 100
子查询：SELECT COUNT(DISTINCT S2.score) FROM Scores S2 WHERE S2.score >= 100
结果：COUNT([100]) = 1
最终：(100, 1)

-第2步：处理 S1.score = 90
sql
外部查询：取出分数 90
子查询：SELECT COUNT(DISTINCT S2.score) FROM Scores S2 WHERE S2.score >= 90
结果：COUNT([100, 90]) = 2
最终：(90, 2)

## 总结分析：

1.窗口函数性能更好